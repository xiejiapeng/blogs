---
layout: post
title: Spark Sql!
---

Next you can update your site name, avatar and other options using the _config.yml file in the root of your repository (shown below).

![_config.yml]({{ site.baseurl }}/images/config.png)

The easiest way to make your first post is to edit this one. Go into /_posts/ and update the Hello World markdown file. For more instructions head over to the [Jekyll Now repository](https://github.com/barryclark/jekyll-now) on GitHub.
本文主要研究Java的内存分布。更严格一点来讲，本文研究的是Hotspot的JVM的内存布局。JVM是Java代码运行的虚拟机，对于操作系统来说，它是一个进程，用于解释运行Java类文件的字节码或者即时编译后的机器码。jvm进程和其他进程一样，有自己专属的虚拟内存空间，主要来讲分为如下几块

中文名分别为：方法区，堆，栈，PC寄存器和本地方法栈。
我们在前文介绍了Java类文件的结构。虚拟机在加载这个类的时候，会将这个类的信息加载到内存中，对应于jvm的方法区中。只要一个类仍然被引用，方法区中关于这个类的信息就一直在。
如果类卸载了，就会从方法区中回收这部分内存，对应的，如果类太多，方法区会发生OutOfMemory Error。
类卸载的必要条件为：类的加载器对象卸载+类对应的Class对象没有被引用+这个类的对象全部被卸载

堆和栈是jvm内存活动的主要区域。堆是jvm用于分配对象内存的地方。当一个对象的类确定的时候，一个对象的占用空间也就确定了。对象占用的空间包括 对象的头+对象的实例数据。对象头占用的区域大小是固定的，为16字节，包含8字节的mark word和8字节的指向类信息的指针（如果开启指针压缩，则只有4字节。如果在32位机器上，对象头占用空间为8+4字节）。对象的实例数据占用的内存由具体类型决定，值得注意的是jvm要求Java对象的占用空间按照8字节对齐，所以如果实例数据不满足要求，需要填充一定字节作为padding。

https://www.cnblogs.com/rickiyang/p/14206724.html

这里我们提一下，java中的指针压缩
我们知道，在32位的机器中，最多能表示2^32个字节地址，一共为4GB。在64位机器上，寻址的比特位更多，但是每个地址占用的空间由32bit变成了64bit，这样保存引用类型的变量需要的内存变得更大。这样虽然理论上内存使用上限更高（这个是理想状态），但实际的是空间占用更大了（这个是实际状态）。那有没有可能仍然只使用32位地址，但是能够寻址超过4GB的内存呢？

java通过地址对齐的方式解决了这个问题。java命令所有的引用地址按照8字节对齐，即java中对象的大小必须是8字节的整数倍数。这样的话，java引用都是8的倍数，他们的二进制表示都是xxxxxxx000，前面的29位随机，但是后面的3位固定为0。此时能够表示的内存地址为2^29*8=4GB。此时的内存分成了2^29组，每组都有8个字节。因为最后三位固定为0，那么在编码的时候就可以用29个bit表示对象的地址！

如果用29个bit表示对象的地址，那么就还有3位bit浪费了，所以java仍然使用32为表示对象地址，但实际的对象地址为这个地址左移3位，然后末尾填充0的结果。从结果来看，这个地址像是占用了35位地址，所以它能寻址的内存扩大到了2^35=32GB，但存储的时候仍然只存储32位。

32位机器上面，物理内存只有4GB，那么32GB这个极限其实是没有意义的。因为从对象的地址映射到某个字段的时候需要这样处理：对象地址*8+偏移量。对象地址如果用尽32位的话，这里的物理地址就超出极限了，所以是没有意义的。但是在64位机器下面，最多的物理内存肯定是超过32GB的。此时32位的对象地址*8+偏移量的上限32GB是不会超过物理内存的。

在64位机器下面，用32位地址引用对象，寻找某个字段物理地址时就是（32位引用地址）*8+偏移量。偏移量由类确定。（32位地址引用）*8是对象在64位机器中的实际物理地址。当然，实际物理地址在保存到堆中的时候要除以8，才能适应32位的需要。
64位机器中，对象的物理地址为0x[00..0(29)][xx..x(32)][000]，堆上地址为xx..x(32)

如果启动jvm的时候设置堆空间大于32GB，就没法使用指针压缩了，因为32位逻辑地址+三位偏移是无论如何也无法寻址超过32GB的物理地址的。除非扩大32，或者扩大对齐的字节数。我们把堆空间看成8字节的格子，如果设置大于32GB，那么格子的个数就超过了2^32个，就无法用32位来作为对象引用地址了。

堆空间为32GB，就要有35寻址的能力。因为堆中每个变量的位置相对于对象引用的位置都是确定的（由类确定），那么只要对象有35位的寻址能力即可。在堆中，对象引用用了32位，加上3位填充，相当于对象的物理地址占用了35位，所以有35位寻址能力。

栈是线程的专属空间，Java中方法的调用和结束都伴随着栈中的栈帧的入栈和出栈。我们在介绍类文件结构的时候已经看到，Java中的方法都需要一定空间的本地方法表和操作数栈，它们是就是保存在栈帧中。

程序计数器也是线程专属的空间。
本地方法栈是执行本地方法的栈空间。

jvm虚拟机在启动的时候根据参数-Xms指定的空间申请内存作为堆内存，这部分内存为虚拟机堆空间的分配内存（了解操作系统中虚拟内存和物理内存的关系），如果这部分分配内存不够的话，jvm最多可以申请到-Xmx大小的堆内存。下面我们介绍jvm的方法区，堆的主要结构，因为这两个空间的使用不像栈那么固定。

方法区
方法区是Java语言规范定义的名词，它其实并不是专指某一个内存空间。在Java8之前，jvm将方法区实现在永久代中，并且不进行垃圾回收。在Java8中，方法区被实现在单独的元空间中。元空间独立于堆内存中。在方法区，也就是元空间中，主要保存如下种类的数据：

如果了解过类的class文件布局的话，还是比较容易理解上面内容的。方法区中数据分为如下几种：
类信息，每个类都对应一个类信息，类信息内部包含
类型信息：这个类的类型信息
类常量池：class文件的常量池保存到这里，其中的符号引用被替换为了实际引用
字段信息
方法信息
类变量
类加载器引用
class实例引用
方法表
运行时常量池
每个class文件都维护了一个常量池，常量池中包含对方法，字段，类型的索引。在加载类的时候class文件的常量池会加载进入到方法区的类型常量池中。

每个类都对应一个运行时的类型常量池。在class文件中，类的常量池中的方法，类型从符号引用被替换成实际引用放入到常量池中，字面量加入到元空间运行时常量池中。在Java7之前，运行时常量池和字符串常量池都在永久代中，Java7将字符串常量池加入到了堆中，到了Java8取消了永久代，运行时常量池进入了元空间，而字符串常量仍然在堆中。String对象调用intern的时候会将自己的引用放入到字符串常量池中，直接声明的字符串常量也放入在字符串常量池中。
Java的非私有的实例方法在执行的时候找到方法区的对应方法，得到字节码和本地变量表和操作数栈信息。此时为了在方法中使用到对象的实例信息，需要将对象的this指针加入到本地变量表中，用于对对象进行索引。如果是静态方法则无法找到this指针，使用this指针编译器会报错。当然了，非私有实例方法的调用需要通过方法表来最终定位到方法的地址，这个在其他文章中已经做过介绍了。

堆
相对于方法区中数据的复杂性，堆的使用则清晰很多了。在堆中只有一种数据，那就是对象。在堆中分布着大大小小的对象。最难的问题是对这些对象进行垃圾回收。jvm使用可达性分析方法判断一个对象是否仍然存活。在进行可达性分析之前，需要判断有哪些引用指向的对象是确定存活的，再以这些对象为根(gc root)，寻找其他必须存活的对象。gc root通常通过如下方式确定
栈上引用的对象（本地变量表）
类的静态属性引用的对象
方法区中常量引用的对象
本地方法栈引用的对象
还有一种特殊的，当分代收集的时候，来在于不进行回收的区域的引用
要想进行垃圾回收，就要遍历上面的区域，以他们为根，寻找对象。这个过程通常需要stop the world，从而得到稳定的对象布局。否则分配内存的线程和垃圾回收的线程冲突，容易造成误回收。当暂停一切线程后，垃圾收集线程又要怎么遍历gc roots呢？比如栈，难道需要每个栈帧都遍历一遍吗。如果是这样的话，也不过影响了一些性能，慢点还可以接受，关键是，垃圾回收的线程是怎么识别某个局部变量是一个引用呢？我们假设在某个线程的栈上有如下的栈帧

在栈帧中，黄色的数值12345代表一个整数，而蓝色和灰色的数值是一个引用类型，它也占用4个字节，指向的是堆上面的对象。早期的gc使用的是叫做保守式gc的方式，它无法区分一个数值到底是整数还是引用，只能把这个数值当成引用，从而作为gc roots。对于堆中对象的某个实例字段亦是如此。这样的坏处是
如果某个对象死了，仍然有误判的引用指向他，觉得这个对象没有死
对象没有办法移动，因为对象移动就要修改对象的地址。比如67890这个栈帧中的本地变量执行对象obj，如果obj移动了，就要修改67890这个数值为其他值。但是在不清楚67890到底是不是引用的前提下，虚拟机不敢贸然修改这个值，要不然会把某个值是67890的整数给错误修改了
因此在保守式gc下，对象无法移动，并且有些死去的对象无法回收。对于对象移动这件事情，可以使用句柄池的方式实现。在引用对象的时候，可以让67890这个地址引用到一个句柄，通过句柄执行一个对象。如果对象移动了，就修改句柄池的地址即可，67890这个数值是不用修改的。这种方式虽然解决了对象移动的问题，但是增大了引用对象的开销，在现在已经被放弃了。

鉴于保守式gc的种种缺陷，产生了一种叫做半保守式，或者叫做根上保守的gc方式。对于从栈帧出去的引用和保守式gc没有不同，但是从对象执行其他对象的引用被赋予了类型，把它作为了类型信息的一部分。

从栈帧直接引用的对象依然是不可移动的，但是从对象obj引用出去的指针类型被写入了类的信息中。比如类中有变量int a 和 obj  b，a和b虽然都占用4个字节保存在对象空间内，但是对象的类型信息告诉我们b这个字段是一个引用，那么在b指向的对象移动后，就可以放心大胆对b进行修改。

半保守式gc解决了部分保守式gc的问题，但是现在对于栈帧上面的引用还是没有办法识别。后来jvm引入了准确式gc。在准确式gc中，可以识别任意一个位置的数据的类型是什么。比如记录下67890这个位置的数不是整数，而是一个引用，那么所有问题就解决了。在Hotspot中这个信息叫做OopMap。在对象的类型信息里面记录了自己的oopmap，记录了在该对象内什么偏移量上是什么类型的数据。对于方法也要记录OopMap，在执行方法的时候要记得更新oopmap。执行方法的时候也不是每执行一行代码就执行一次，而是在称为安全点safepoint的地方记录oopmap。所以方法每次执行到安全点的时候记录oopmap，从而得到一个稳定的全局的引用关系。
在gc的时候，如果方法没有进入安全点，则不能进行gc，所以安全点的位置选择尤为重要。如果安全点过于密集，那么记录oopmap的开销就比较大；如果安全点过于稀疏，那么gc的时候等待线程进入安全点的时间就比较大，gc效率就低。不论安全点如何选择，我们可以肯定知道安全点最密集的分布，比如：
安全点的密度不能低于字节码指令的密度，不能在字节码执行内部创建安全点，因为这个时候对象引用关系是不稳定的，只有一条字节码执行完了才有一个一致的对象引用全局关系
jni本地方法中不需要安插安全点。本地方法执行过程中不会改变对象关系。如果在本地方法中安插安全点，完全可以将这个安全点放到本地方法开始的地方。线程执行到本地方法开始的地方的时候进入安全点，记录oopmap。然后这个线程甚至还可以继续运行，因为本地方法不会影响对象关系。
jit生成的机器码中，在非计数循环回边的地方安插安全点或者方法返回之前安插安全点。

jni方法中涉及到的对象指针都用句柄包装了起来，jni中对象的指针实际上是指向句柄的指针，


所以在执行本地方法的时候不需要记录oopmap。因为没有人会关心本地方法的栈帧中的本地变量是不是引用类型。他们总是指向句柄池中句柄，所以只要扫描句柄池就知道有哪些根对象了。

以上就是从栈帧中寻找gc roots的过程和优化了。我们知道gc roots中包含了一种特殊的引用，即在使用分代收集的时候，来自不进行收集的其他堆空间的引用。

在上面例子中，假设我们准备回收edge 2和survisor区域的对象，也就是进行young gc。young区域可能有一些对象不被gc root直接引用，也不被其他young区域其他对象引用，他们理应被回收的。但是在老年代有一个对象o2指向o1，那么o1应该是不被回收的。如果每次进行young gc的时候都进行全堆的扫描，那么进行分代回收就没什么意义了。所以在进行young gc的时候，最好能知道还有那些老年代对象在指向这些年轻对象。jvm中使用一种叫做card table的方式记录某块内存区域是不是有对其他区域的引用。卡表是一个字节数组，数组的每个元素对应堆上一片512字节的区域。对于某个地址x，通过x >> 9就得到其在卡表中的索引了。如果这个区域内部的引用发生变化的时候，就将这块区域标记为脏页。比如引用x的对象发生变化，则进行
card_table[x >> 9] = 0;
这个过程是自动进行的，通过写屏障完成。如果在发生引用变化的时候就写卡表，会带来虚共享的问题。比如cpu的一个缓存行为64字节，如果某个卡表项变化就被写入的话，将带来64个卡表项的缓存的失效，简介影响了程序的性能。所以在标记卡表的时候要进行判断，如果卡表原来不为0，再标记为0
if(card_table[x >> 9] !=0)
    card_table[x >> 9] = 0;

所以在进行minor gc的时候耗时主要发生在
复制活跃对象
扫描卡表


垃圾收集器
关于gc垃圾收集器的介绍很多，我们这里主要阐述一般的gc方法。回收内存中垃圾对象占用的空间一般有如下几种：
标记-清除
标记-压缩
复制
https://tech.meituan.com/2020/11/12/java-9-cms-gc.html
要想进行垃圾收集，第一步骤就是标记垃圾对象。在前面我们已经介绍了对象标记的过程了，主要是通过可达性分析寻找所有存活对象。经过标记阶段以后堆中对象的存活情况如下：


绿色代表空闲区域，蓝色代表存活的对象，灰色代表死去的对象

标记-清除
通过标记清除法可以将死去对象占用的内存标记为空



这种回收方式将带来两个问题，那就是
堆中存在大量的内存碎片
堆内存的分配效率很低
因为在堆中空闲的内存不是连续出现的，所以需要用链表记录所有的空闲区域。而在分配的时候也要根据链表寻找可用的内存空间。标记清除法也不是没有好处，对于那些存活的对象，一次gc的过程是不会移动到这部分对象的。因为标记清除的这个特点，其适合运用在存活对象较多，而死去的对象较小的场景下。在jvm使用分代收集的背景下，标记-清除法适用于进行老年代的垃圾收集。

标记-压缩
为了消灭堆中空闲内存的碎片，标记移动在回收死去对象的同时，还将存活的对象移动到堆的同一侧


相对于标记-清除来说，标记-移动完全减少了内存碎片的产生，这样进行空间分配的效率也很高。它的代价就是需要对存活的对象进行移动。

复制
复制算法的实现最为简单，它将空间分成两块，每次使用的时候只使用一半的区域。每次在回收的时候将其中一半的存活的对象复制到另一半中。这个算法的缺点就是空间浪费太多了；优点和标记-压缩一样，但是算法实现起来会比标记-压缩稍微快一点。当存活对象很少的时候，使用复制算法的效率是很高的。为了解决空间浪费的问题，将内存分为了如下三块区域


对象的分配总是分配在Eden区域，当eden区满时进行垃圾回收，将eden和前几次存活的对象一起复制到另一个survisor区域中。这个算法的假设前提就是存活的对象很小，这符合年轻代的对象特征，所以复制算法是年轻代的回收算法。

基于各种算法的实现和gc的目标，产生了各种不同的垃圾收集器。这些垃圾收集器大多数是基于分代回收的理念，而后来的g1收集器则基于分region收集的理念。基于分代收集的垃圾收集器有如下几种
ParNew
Serial
Parrel Scavenge
CMS
Serial Old
ParrelOld
以上垃圾收集器都是定位于年轻代或者老年代的收集，所以他们需要配合着使用


我们常用的CMS收集器经常搭配着ParNew和Serial一起使用，其中ParNew是Serial的多线程版本。ParNew收集期间是需要stop the world的，而CMS进行老年代回收时的目标是最短的停顿时间。CMS在进行垃圾收集的时候能让gc线程和用户线程并发执行的时候就并发执行，尽可能不影响用户线程，但这样也牺牲了吞吐量。

下面我们对具体的垃圾回收算法进行深入介绍
copying算法
首先我们看一下常见的copying 算法。copying算法使用两块内存空间，每次回收的时候将存活的对象移动到空闲的内存区域中。比如这两块区域叫做S0和S1，我们关注如下几个问题
怎么遍历查找到所有存活的对象
怎么移动对象到另一个区域，同时维护对它的引用
copying算法需要遍历对象，所以它是stop the world的。copying算法用于寻找存活的对象，所以它适用于年轻代的gc，因为年轻代每次gc存活的对象都很少，大多数都是临时的对象。copying遍历查找所有存活的对象，需要解决两个问题
遍历的根对象怎么确定
使用深度优先遍历还是广度优先遍历
copying算法的根对象也就是gc root，它主要是堆外对堆内的引用。但是因为我们是分代回收，所以从老年代引用到年轻代的对象也应该作为gc root。所以遍历的根对象包含gc root和部分老年代对象。确定老年代的root的时候，既然进行的是分代回收，肯定不能全部遍历老年代的。hotspot采用了remember set的技术维护了那些有引用指向年轻代的老年代对象。



每当发生老年代对象引用的改变（或者发生年轻代晋升的时候），同时确定引用指向年轻代的时候，通过写屏障write barrier将这个老年代对象加入到rs中。hotspot为了优化这个过程的执行效率，采用了卡表card table的技术。他将整个老年代区域分成512个字节的小区域，如果在这个区域中发生了指向年轻代的引用，则对这个区域进行置位。


解决了gc root的问题以后，还要确定使用深度优先遍历还是广度优先遍历。如果使用深度优先遍历，就从gc root开始，不断遍历它引用的对象，直到引用到了老年代或者没有引用的时候再回溯。我们在对图进行深度优先遍历的时候，需要保证不会访问重复的节点。在gc中进行dfs的时候，可以为每个节点增加标记位代表是否被访问过。另外还有一个重要问题就是如果对象被访问过了（被copy过了），后面的对这个对象的引用怎么随之修改呢？这里可以通过forwarding指针解决，在对象的头部引入forwarding区域，指向copy以后的新地址，那么当其他引用遍历到这个对象时，就直接更新为这个forwarding指针即可。dfs的伪代码如下：
void copy_gc() {
    for (obj in roots) {
        *obj = copy(obj);
    }          
}
//copy总是返回对象新的指针
obj * copy(obj) {
    if (!obj.visited) {
        new_obj = to_space.allocate(obj.size);
        copy_data(new_obj, obj, size);
        obj.visited = true;
        obj.forwarding = new_obj;
        for (child in obj) {
            *child = copy(child);
        }
    }
    return obj.forwarding;
}
深度遍历需要借助递归实现，也可以借助栈实现，需要额外的存储空间。图的遍历也可以使用bfs的方式。bfs需要借助队列的实现，但是在存在to空间的情况下， 可以将to空间当做队列使用，这样bfs与dfs相比是节约的执行空间的。bfs的伪代码如下：
void copy_gc() {
  for (obj in roots) {
    //复制对象
    *obj = copy(obj);
  }
  //to空间当成队列使用，队列的范围为[to.scanned,to.top]
  while (to.scanned < to.top) {
    for (child in obj(scanned)) {
      *child = copy(child)
    }
    to.scanned += obj(scanned).size();
  }
}

但是bfs与dfs相比有一个很隐蔽的缺点，它丢失了引用的本地性。我们假设有一个引用A->B，在使用dfs的时候，访问A以后立即就会访问B，所以他们分配的空间是相邻的。


当obj AA和obj BB相邻时，从obj AA访问obj BB的时候，能提高缓存的命中率，这是比bfs好的地方。bfs在遍历的时候是按层级遍历，即使A引用B，B分配的地址也远远在A后面。


接下来我们再看一下mark sweep算法，以及它的代表引用cms回收器

mark sweep & cms
ms算法的原理是对对象进行遍历，标记，然后清除掉没有被标记的对象。这种描述是比较抽象的，我们需要明确几个关键问题：
怎么遍历，从哪里开始遍历
怎么标记
什么叫清除未被标记的对象
先看第一个问题，遍历的问题。在copying算法部分我们已经介绍了基于dfs和bfs的遍历算法，在ms算法里依然适用。但是在ms中不需要维护跨代引用，即年轻代的remember set。这是因为年轻代的存活对象很少，可以在ms之前对年轻代进行一次回收，再遍历所有年轻代对象即可。
第二个问题是标记的问题，一般来说有两种方法标记存活的对象
在对象头里面加入标记位，如果置位了就表示是存活的对象，反之是待清除的对象
采用标记位图，采用两个位图，一个标记活跃对象的起始位置，另一个标记活跃对象的结束位置。通过位图，可以明确知道哪个对象是活跃对象还是回收对象
第三个问题是清除回收对象。清除的含义是释放对象的占用空间。在使用ms的内存区域，使用的是空闲链表的方式分配空闲内存（与malloc的分配算法类似）。回收一个对象的含义就是将对象的内存重新放入到空闲链表中。

以上就是ms算法的基本原理。因为涉及到全图的标记，所以ms是需要stop the workd的。为了减少stw的时间，cms因此而诞生。cms的全称就是concurrent mark sweep。顾名思义，它是并发执行的，即工作线程与gc线程一同执行。我们先解释为什么mark sweep不能和工作线程并发执行。以bfs为例，假设有三个对象A，B，C。A->B，C为垃圾对象
A通过根对象加入队列，然后将它的child，也就是B加入队列，然后A出队列。以后A再也不会访问。
B出队列，B没有child。假设此时A又引用C对象，但C没有进入队列的机会
循环结束
A作为访问过的对象，又被工作线程引用向了C对象，但是C没有进入队列的机会了，所以C被作为垃圾回收掉。这肯定不行的，因为A引用了C对象。要解决并发下的问题，有两种方式
如果A指向了C，将C加入到队列中（通过类似于write barrier的方式）=> 如果后来A对C的引用又消失了，C就成了浮动垃圾。但也没啥问题，等待下一次回收好了。
如果A指向了C，将A再次加入到队列中 => 不会产生浮动垃圾
cms在并发的时候采用了类似于第二种的思路，它利用了card table。在遍历的阶段，如果又发生了引用的变化，比如X引用了Y，则将X所在的card置位。在上面例子中，A被工作线程引用向C以后，将A的card置位，然后再找个时机对card被置位的引用再进行遍历。cms的主要思想其实就是这个，它的全过程如下：
初始标记：stop the world。这一步主要是找出根对象，不太好并发。并且这里不关心年轻代引用老年代的跨代引用情况
并发标记：也就是上面提到的bfs过程，如果并发阶段工作线程又改变引用关系，用card置位。一次循环结束以后发现有card被置位了，就再执行一次循环（从card table开始）。第一次循环叫做预清理(prelcean)。如果某一次循环发现card table没有变化，就结束并发标记阶段。如果一直有card置位，循环到一定次数以后，也结束并发标记阶段
重标记：这一次为card table遗留的引用扫尾，同时遍历年轻代的对象，找出跨代引用。这一步需要stop the world。
并发清理：并发地将垃圾对象加入到freelist，已达到清除的目的。（这里应该需要借助标记位图的实现）
最终清理
在并发标记阶段因为使用到了card table，而年轻代回收也要用到card table。所以Hotspot引入了MUT来维护跨代引用，在并发标记开始之前，将card table复制到MUT中，然后年轻代的回收通过MUT进行跨代扫描。因为card有512字节，所以被“误判”的对象会成为浮动垃圾。比如这里的D对象，由于A在并发阶段引用了B对象，导致A的card被置位，所以card中的D对象也被当做了存活对象。


一般来说，新生代指向老年代的引用不会太多，但是偶尔也会发生这种引用很多的情况，如果出现了这种情况，可以在重标记之前，进行一次年轻代 GC，这样可以减少年轻代中的对象数量，减少重标记的停顿时间。这个功能可以使用参数 -XX:+CMSScavengeBeforeReMark 来打开。

G1 收集器
g1收集器作用于整个堆空间，而CMS作用的仅仅是年轻代。在g1 collector下，整个堆被分成若干个大小相同的区域。g1 gc既可以回收年轻代，也可以回收老年代空间。在回收年轻代的时候，采用STW的方式遍历所有的存活的对象，并复制到其他空白的region中[疑问：如果没有空白region，先进行mixed gc还是full gc]。我们重点关注的是老年代的gc。在介绍CMS的时候我们着重研究了它的并发标记的过程。其实任何并发收集的gc算法都面临并发标记的问题。
并发标记问题
并发标记的经典模型就是三色模型，它将所有的对象分成三种分类
黑色：已经完成标记的对象，且它的引用也都进行过了标记
灰色：被黑色对象标记过，但是它的部分（或者全部）引用还没有进行标记
白色：还没有进行过标记的对象
在标记的过程中，黑色对象和灰色对象越来越少，最后堆中剩下的白色对象就是确定要回收的对象了。
并发标记的最大的困难在于
在并发标记的过程中，某个白色对象被黑色对象引用
这个白色对象被断开所有引用
白色对象被断开所有引用后，理论上来说应该就成了永久白色的对象了，除非又有其他对象引用了它。如果是其他以后会变成灰色的白色对象，或者是某个灰色对象引用到了它，还能救活它。但如果是已经确定不会被访问到的黑色对象，这个对象有可能就再也没有变灰变黑的可能了。这种只被黑色对象引用的情况是阻碍并发标记的最大问题！

对于并发标记的解决有两个方案
incremental update writer barrier：如果一个断联的对象被黑色对象引用的话，将引用它的card table置位
SATB(snapshot at the beginning) writer barrier：如果一个对象被断联，那么将其标记成灰色
incremental的思路是如果黑色对象引用了白色对象，将card table置位，这样在并发标记阶段结束后，系统知道，白色对象有一次复活的机会，因为有可能card table中的对象引用了他们。此时只要再遍历card table就可以复活它们。SATB的思路是，在并发标记开始的阶段对全堆做一个快照，这样对象即使被断联，也会被认为是灰色的对象。SATB自然不需要遍历这个堆，而是在某个对象被断联的时候，进行某种处理，保证它们会被标记。这两种思路对于可能被误判的对象的思路形象来讲是这样的
incremental update writer barrier：对中途被引用的对象使用复活卡
SATB writer barrier：对被断开的对象发放免死金牌（没有被断开的对象自然会判定为灰色和黑色，不需要这个）
免死金牌保护了所有对象，所以浮动垃圾会比较多的，但是复活卡会在有新引用发生的时候发放，所以浮动垃圾相对少一些。

上面是对两个方案的原理阐述，那么在CMS和G1中，他们到底是怎么实现的？
在CMS中，当有新的引用发生时，无条件记录这个引用关系。我们知道CMS中用card table保存了从老年代到年轻代的跨代引用。在并发标记阶段，如果从老年代发生了新的引用，则将对应的card table置位。为了防止对card table用途的混淆，CMS使用了mod union table来复制card table用来做年轻代的young gc。但是从年轻代或者root也有可能发生对白色对象的引用的，而年轻代是没有card table的（年轻代引用变化很频繁，dirty card table会比较多，没有必要）。这样在并发标记结束以后要扫描一下根集合。这样的话，在并发标记结束以后，采用incremental update writer barrier需要再扫描一遍根集合和老年代的card table。
对对象的存活标记是使用bitmap实现的。这个过程中，如果分配了新的对象，这个对象处理过程类似的。如果对象被root引用，则重新标记的时候能复活。如果对象被黑色引用，则通过card table复活。如果对象被灰色对象引用，那么不需要复活，后面它就会标记为灰色和黑色。

在G1中，当有引用断联（即对引用字段赋值）的时候，就标记对象为存活（发送免死金牌）。标记过程比较复杂，也依赖write barrier。G1为了降低对mutator线程的影响，G1将这个过程设计为异步执行。G1为每个java线程分配一个队列，叫做STABMarkQueue。在发生引用字段赋值时，write barrier将老的引用放到队列中。如果队列满了，就把这个队列加到全局的队列集合SATBMarkQueueSet中等待其他线程处理，自己再申请一个新的队列。被加入队列的对象最后会标记为存活对象（并发标记线程定期检查全局SATBMarkQueueSet的大小，满足一定阈值才会处理）。被加入SATB的那些对象也要进行遍历，因为他们也被认为是存活的对象了。
如果在并发标记中产生了新对象怎么办？在CMS中，有一个复活阶段，新生对象是有复活的机会的。但是在SATB中，只对并发开始的引用进行了快照，这期间产生的新对象如果被黑色对象引用，也没办法救活啊，因为这里使用的是免死金牌机制啊！所以G1的并发标记阶段还复杂一点，它还要将并发标记阶段产生的新对象也标记。

在某一轮并发标记的时候，假设此时这个region的已分配内存的边界指针叫做top。在这一轮分配完成后，能够产生一个bitmap表示截止到top为止的存活对象。产生方式介绍在上一段。截止到top指针的对象因为有免死金牌的存在，永远可以被标记。在这轮标记结束后，region又产生了一些新对象，此时分配指针从top移动到了top2。理论上来说top到top2这部分的新对象也要被标记。所以此时又要进行新一轮的标记。这一次标记不会在原来的bitmap和TAMS基础上修改，而是将此时得到的bitmap和TAMS赋值给临时的prevBitmap和prevTAMS（prev的结果提供给Evacuation使用）。prevBitmap和prevTAMS代表上一阶段截止到到prevTAMS处的存活对象。此时指针状态为
bottom - prevTAMS(nextTAMS) - top
因为并发的缘故，region的分配指针变成了top。这时将prevTAMS到top间的对象进行标记，并设置nextTAMS为当前的top。
bottom - prevTAMS(prevBitmap) - top(nextTAMS,nextBitMap) - ...
在这一轮标记的时候，top又会向前进，此时nextTAMS又要落后于top了
bottom - prevTAMS(prevBitmap) - nextTAMS(nextBitmap) - top
总结一下就是：（引用自R大原文）
G1的concurrent marking用了两个bitmap：
一个prevBitmap记录第n-1轮concurrent marking所得的对象存活状态。由于第n－1轮concurrent marking已经完成，这个bitmap的信息可以直接使用。
一个nextBitmap记录第n轮concurrent marking的结果。这个bitmap是当前将要或正在进行的concurrent marking的结果，尚未完成，所以还不能使用。

对应的，每个region都有这么几个指针：
|<-- (1) -->|<-- (2) -->|<-- (3) -->|<-- (4) -->|
bottom      prevTAMS    nextTAMS    top         end
其中top是该region的当前分配指针，[bottom, top)是当前该region已用（used）的部分，[top, end)是尚未使用的可分配空间（unused）。
(1): [bottom, prevTAMS): 这部分里的对象存活信息可以通过prevBitmap来得知
(2): [prevTAMS, nextTAMS): 这部分里的对象在第n-1轮concurrent marking是隐式存活的
(3): [nextTAMS, top): 这部分里的对象在第n轮concurrent marking是隐式存活的


remember set
G1回收的时候是按region回收的，被回收的region叫做CSet。所以不在CSet中的对象都可以作为这个region的根对象。G1也是通过remember set保存这种跨region的引用关系的。与CMS中使用card table不同的是，每个region中的remember set记录的是有哪些region引用到了自己。这个remember set叫做point-into RSET，它是一个hashtable, key是别的region的起始地址，value是一个集合，里面的元素是card table的index。

Evacuation
Evacuation意指将对象从一个region转移到另一个region。这是需要STW的。我们回忆copy算法是怎么实现的，它是边遍历，发现存活对象就修改引用。Evacuation借助了并发标记的结果prevBitmap确定哪些对象是存活的。

关于cms和g1的帖子
http://www.javaadu.online/?p=465]%E7%AC%AC%E5%9B%9B%E3%80%81%E4%BA%94%E8%8A%82
https://hllvm-group.iteye.com/group/topic/44381



